Here is the updated documentation for **Layer 3: The Core Orchestrator**.

I have refined the technical specifications to align with the "Split-State" architecture we discussed, ensuring the distinction between the in-memory grid (Instant Faceting) and the on-disk vectorized storage (DuckDB) is clear.

---

#Layer 3: The Core Orchestrator (Java / OpenRefine Heritage)**Component:** `sentient_core`
**Technology:** Java 17, Jetty 10, Butterfly Framework
**Role:** State Management, API Gateway, and Final Adjudication

---

##1. OverviewThe **Core Layer** is the stable foundation upon which the experimental AI layers rest. It does not perform NLP; it performs **Management**.

**Philosophy:** "Hybrid Memory Architecture"
Unlike the original OpenRefine "Database in RAM" model—which hits a hard ceiling with large AI vectors—SenTient adopts a split-state strategy to handle the massive payloads generated by Falcon and Tapioca:

1. **Hot Data (RAM):** Row IDs, Status flags (`JUDGED`, `PENDING`), and Raw text values. This preserves the **Instant Faceting** capability (< 10ms filtering) that users expect from OpenRefine.
2. **Cold Data (DuckDB Sidecar):** Heavy AI payloads (Feature Vectors, Candidate descriptions, detailed Confidence Scores). These are "hydrated" (loaded) only when the user scrolls them into the Virtual DOM view or exports the data.

---

##2. The Butterfly ArchitectureSenTient retains the **Butterfly** modular framework to handle the HTTP lifecycle, acting as the bridge between the React frontend and the heavy AI containers.

###2.1. The Servlet ModelThe entry point is `com.google.refine.RefineServlet`. It routes requests based on the Command Pattern, decoupling the UI from the processing logic.

* **Endpoint:** `http://localhost:3333/command/core/*`
* **Routing Logic:**
1. **Frontend** sends `POST /command/core/reconcile`.
2. **Butterfly** looks up the registered **Command** class (e.g., `ReconcileCommand`).
3. **Command** validates the request and triggers a **Process** (`LongRunningProcess`).
4. **Command** returns a JSON response `{"code": "ok", "jobID": "123"}` immediately, preventing UI blocking.



###2.2. The Async Process ManagerBecause Layer 2 (Falcon) can take minutes to process large datasets (e.g., calculating vectors for 100k rows), the Core uses a **Non-Blocking** architecture.

* **Class:** `com.google.refine.process.ProcessManager`
* **Mechanism:**
* The `ProcessManager` maintains a priority queue of `LongRunningProcess` objects.
* It uses the `ThreadPoolExecutorAdapter` (configured in `butterfly.properties`) to allocate threads for API calls to OpenTapioca and Falcon.
* **Polling:** The Frontend polls `/command/core/get-processes` every 500ms to update the progress bar, ensuring the user is never left guessing.



---

##3. The Data Model (The "SmartCell" in Java)The most significant modification in SenTient is the extension of the `Cell` and `Recon` objects to support "Split-State" persistence.

###3.1. The `Cell` ObjectLocated in `com.google.refine.model.Cell`.
It is the atomic unit of storage in the grid. In SenTient, it is polymorphic:

* **Raw State:** Contains only the `value` (String/Number).
* **Reconciled State:** Contains a pointer to a `recon` object.

###3.2. The `EnhancedRecon` ObjectWe have extended the standard `Recon` class to support the **Consensus Score** and **Lazy Loading**. The heavy data is explicitly marked `transient` so it is not held in the Java Heap indefinitely.

**Fields added to Java Class:**

```java
public class Recon {
    // --- Standard OpenRefine Fields (Kept in RAM) ---
    public long id;
    public String judgment; // MATCHED, NEW, NONE
    public Object [] features; // Lightweight feature flags
    
    // --- SenTient Extensions (Lazy Loaded from DuckDB Sidecar) ---
    
    // NOTE: These fields are transient. They are null by default and 
    // only hydrated by DuckDBStore.fetchVisibleRows() when the 
    // viewport requests them.
    
    public transient List<ReconCandidate> candidates; 
    
    // The aggregate confidence score calculated by Falcon
    public transient float consensusScore; 
    
    // The raw embedding vector (e.g., [0.1, -0.5, ...]) used for cluster visualization
    public transient float[] featureVector; 
}

```